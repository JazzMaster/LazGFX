speed under SDL2: 

Theres confusion in SDL:
	SDL 1.2 uses Surface ops
	SDL 2.x builds on Surfaces(you still need them in some cases) and adds 2D compositing support(GL)
		Most ops will switch to Render calls, but not all.
		all uses clauses and include files must point to SDL2. You cannot mix 1.2 and 2.x.
		
	SDL2 uses ortho 2D quads but adds support(hackish) for 3D OGL.
		
	SDL_GPU isnt really an advanced unit- its optimized unit "utilizing the renderer".
		I inadvertently "half-assed" half the color routines myself.

			Fpc Dev team(more stable codebase based upon Borlands BGI) has the remaining routines.
				These may not be the most optimal routines- they are the most tested.

	SDL by itself- does NOT do 3D. I dont think it ever will.

How to write good games:

	SDL1.2 (learn to page flip or animate)
		YES- animation like mickey mouse 1950s flip-books

	SDL2.0 (learn how to use the renderer and "render to textures as surfaces")

	Learn OpenGL or freeGLUT
	WRITE CODE(DUH)!

If you need to see SDL in action:

	Postal(1) uses SDL.
	Hedgewars uses SDL v1.2.
	Nexiuz and SuperTux uses SDL 2(w OGL?)


----

You can get 1ms or faster if using streaming textures and certain color modes
The color conversion is what slows you down.

const
    texWidth:word; = 1024;
    texHeight:word; = 1024;

var 
    texture:PSDL_Texture;
    pixels: array [0..( texWidth * texHeight * 4 )] of byte;

begin
    texWidth:= 1024;
    texHeight:= 1024;

    texture:= SDL_CreateTexture (renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, texWidth, texHeight);

    //do something

    SDL_UpdateTexture (texture, NiL, pixels, texWidth * 4 );
    SDL_RenderCopy( renderer, texture, NiL, NiL );
    SDL_RenderPresent( renderer );

end;

---


I will have to backport my SDL half-assed library. I may yet need it.
